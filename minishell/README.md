# minishell

## FAQ

---

**Q**: Обязательно ли включать `char **envp` в общую структуры, если можно просто запихнуть все в список и с этим списком работать: изменять, выписывать из него данные и т. д.?

**TLDR**: Нет, не обязательно

**A**: Можно собирать переменные окружения для `int execve(const char *filename, char *const argv [], char *const envp[])` только при необходимости (т.е. когда окружение изменилось). В остальных случаях (т.е. когда окружение не изменялось) можно ссылаться на данную переменную, в которую окружение уже собрано. В таком случае мы будем экономить время, которое уйдет на сборку окружения в двухмерный массив.

*Comment*: Это верно только в случае, когда Вы храните переменные окружения в связном списке (или другой структуре данных, например в RB-дереве). Если Вы изначально все окружение держите в двухмерном массиве и каждый раз при изменении окружения его пересобираете, то эта переменная у Вас скорее всего уже есть.

---

**Q**: Зачем именно делать массив из built-in функций, их же можно просто так вызывать?

**TLDR**: Чтобы список built-in функций был лего масштабируем

**A**: Если использовать не массив, а if/else или switch/case (не разрешен в проекте), то код быстро раздуется при добавлении новых функций. Поддерживать такой код крайне трудно (Представьте что у вас поменялась сигнатура функции. Придется изменять вызов во всех местах, если Вы, конечно, не передаете структуру параметров для функции).

Пример:
```
if (state == 0)
	func_0(params);
else if (state == 1)
	func_1(params);
...
else if (state == n)
	func_n(params);

// Or

switch (state): {
	case 0: {
		func_0(params);
		break ;
	}
	case 1: {
		func_1(params);
		break ;
	}

	...

	case n: {
		func_n(params);
		break ;
	}
}
```

Если же использовать массив, то вызов функции можно будет написать *один* раз, а при добавлении новых функций, просто дописать в определение массива ссылок на функции и увеличить счетчик длины массива на 1

Пример:
```

```

---
