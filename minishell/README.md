<style>
.hr-dashed-gradient {
	margin: 20px 0;
	padding: 0;
	height: 2px;
	border: none;
	background: linear-gradient(to right, transparent 50%, #fff 50%);
	background-size: 16px 2px, 100% 2px;
}
</style>

# minishell

## Оглавление

- [Структуры и переменные](#Структуры-и-переменные)
- [Readline](#readline)

<br />
<br />

## Структуры и переменные

**Q**: Обязательно ли включать `char **envp` в общую структуры, если можно просто запихнуть все в список и с этим списком работать: изменять, выписывать из него данные и т. д.?

**TLDR**: Нет, не обязательно

**A**: Можно собирать переменные окружения для `int execve(const char *filename, char *const argv [], char *const envp[])` только при необходимости (т.е. когда окружение изменилось). В остальных случаях (т.е. когда окружение не изменялось) можно ссылаться на данную переменную, в которую окружение уже собрано. В таком случае мы будем экономить время, которое уйдет на сборку окружения в двухмерный массив.

*Comment*: Это верно только в случае, когда Вы храните переменные окружения в связном списке (или другой структуре данных, например в RB-дереве). Если Вы изначально все окружение держите в двухмерном массиве и каждый раз при изменении окружения его пересобираете, то эта переменная у Вас скорее всего уже есть.

<hr class="hr-dashed-gradient">

**Q**: Зачем именно делать массив из built-in функций, их же можно просто так вызывать?

**TLDR**: Чтобы список built-in функций был лего масштабируем

**A**: Если использовать не массив, а `if/else` или `switch/case` (не разрешен в проекте), то код быстро раздуется при добавлении новых функций. Поддерживать такой код крайне трудно (Представьте что у вас поменялась сигнатура функции. Придется изменять вызов во всех местах, если Вы, конечно, не передаете структуру параметров для функции).

Пример:

```c
if (state == 0)
	func_0(params);
else if (state == 1)
	func_1(params);
...
else if (state == n)
	func_n(params);

// Or

switch (state): {
	case 0: {
		func_0(params);
		break ;
	}
	case 1: {
		func_1(params);
		break ;
	}

	...

	case n: {
		func_n(params);
		break ;
	}
}
```

Если же использовать массив, то вызов функции можно будет написать *один* раз, а при добавлении новых функций, просто дописать в определение массива ссылок на функции и увеличить счетчик длины массива на 1

Пример определения:

```c
// 123 для примера, любое беззнаковое целочисленное значение
#define BUILTIN_FUNC_COUNT 123

// RET_TYPE -- возвращаемый тип
// t_func_ptr -- название типа указателя на функцию
// PARAM_TYPE -- тип параметра
typedef RET_TYPE (*t_func_ptr)(PARAM_TYPE_A a, PARAM_TYPE_B b, ...);

t_func_ptr f_ptrs[BUILTIN_FUNC_COUNT];

f_ptrs[0] = func_0;
f_ptrs[1] = func_1;
...
f_ptrs[n] = func_n;
```

Пример вызова:

```c
f_ptrs[state](params);
```

<br />
<br />

## Readline

**Q**: Уточнение: Prompt - это то что первое в терминале высвечивается и ждет команды от пользователя? Например, то что на школьном маке: at-f5% или если зайти в bash: bash-3.2$?

**TLDR**: Да

**A**: В большинстве современных (и не очень) оболочек `prompt` берется из переменной окружения `PS1`, а затем перед каждым выводом прогоняется через внутренний механизм оценки переменных.

Пример:

```bash
bash-3.2$ export PS1='$(pwd): '
/Users/User/Documents: cd ..
/Users/User:
```

*Comment*: Данный функционал не является обязательным в рамках проекта

<hr class="hr-dashed-gradient">

**Q**: При возврашение readline-ом NULL указателя можно ли сразу завершать программу без захода в лексер, парсер и т.д?

**A**: Да

<hr class="hr-dashed-gradient">

**Q**: В сабжекте написано: иметь рабочую историю. Что кроме добавления команд и очищения  истории ещё надо делать?

**A**: Ничего, история в библиоте `readline` работает из-коробки. Просто добавьте `add_history(line)` после прочтения непустой строки. И не забудьте очистить историю при выходе из оболочки `rl_clear_history()`

<hr class="hr-dashed-gradient">

**Q**: Не подключается функция `rl_clear_history()` (ругается компилятор)
при подключенных библиотеках
`#include <readline/readline.h>`
`#include <readline/history.h>`

**TLDR**: Ошибка на этапе сопоставления зависимостей

**A**: Добавьте флаги в `C_FLAGS` в Вашем `Makefile`

```bash
# Пояснение:
# $(USER) нужно чтобы у любого юзера искал подобный путь
# 8.1.* любой патч с мажорной версией 8 и минорной 1, вдруг у Вас с тиммейтом разные версии readline

-I /Users/$(USER)/.brew/Cellar/readline/8.1.*/include/ -lreadline -L /Users/$(USER)/.brew/Cellar/readline/8.1.*/lib/
```

<hr class="hr-dashed-gradient">
